use crate::utils::{delete_credentials, load_credentials, save_credentials, Credentials};
use clap::Parser;
use client::login_client::LoginClient;

#[derive(Debug, Parser, Clone)]
pub enum AuthSubCommand {
    #[clap(name = "login", about = "Login to Livekit MMLA server")]
    Login(Login),
    #[clap(name = "logout", about = "Logout from Livekit MMLA server")]
    Logout,

    #[clap(name = "generate-api-keys", about = "Generate API keys for the user")]
    GenerateApiKeys(GenerateApiKeys),

    #[clap(name = "list-api-keys", about = "List API keys for the user")]
    ListApiKeys,
}

#[derive(Debug, Parser, Clone)]
pub struct Login {
    #[clap(
        short = 'b',
        long,
        help = "Base URL of the Livekit MMLA server",
        value_name = "BASE_URL"
    )]
    pub base_url: String,
    #[clap(
        short = 'u',
        long,
        help = "Username to login with",
        value_name = "USERNAME"
    )]
    pub username: String,
    #[clap(
        short = 'p',
        long,
        help = "Password to login with",
        value_name = "PASSWORD"
    )]
    pub password: String,
}

#[derive(Debug, Parser, Clone)]
pub struct GenerateApiKeys {
    #[clap(
        short = 'c',
        long,
        help = "Comment for the API key",
        value_name = "COMMENT",
        default_value = "Generated by CLI"
    )]
    pub comment: String,
}

#[derive(Debug, Parser, Clone)]
pub struct Auth {
    // SubCommand
    #[clap(subcommand)]
    pub subcmd: Option<AuthSubCommand>,
}

impl Auth {
    pub fn execute(&self) {
        match &self.subcmd {
            Some(subcmd) => match subcmd {
                AuthSubCommand::Login(login) => {
                    let client = LoginClient::new(&login.base_url);
                    let response = client.login(&login.username, &login.password);
                    match response {
                        Ok(token_response) => {
                            let creds = Credentials {
                                base_url: login.base_url.clone(),
                                token: token_response.access_token.clone(),
                                username: login.username.clone(),
                            };
                            let save_result = save_credentials(&creds);
                            match save_result {
                                Ok(_) => {
                                    println!("Login successful \n {:?}", creds);
                                }
                                Err(e) => {
                                    println!("Error: {}", e);
                                }
                            }
                        }
                        Err(e) => {
                            println!("Error: {:?}", e);
                        }
                    }
                }
                AuthSubCommand::Logout => {
                    let creds_result = load_credentials();
                    creds_result
                        .map(|creds| {
                            let client = LoginClient::new(&creds.base_url);
                            let response = client.logout(&creds.token);
                            match response {
                                Ok(_) => {
                                    delete_credentials()
                                        .map(|_| {
                                            println!("Logout successful");
                                        })
                                        .unwrap_or_else(|e| {
                                            println!("Error: {}. Error Deleting the files", e);
                                        });
                                }
                                Err(e) => {
                                    println!("Error: {:?}. Error from server", e);
                                }
                            }
                        })
                        .unwrap_or_else(|e| {
                            println!("Error: {}. Please login again", e);
                        });
                }
                AuthSubCommand::GenerateApiKeys(api_keys) => {
                    let creds_result = load_credentials();
                    creds_result
                        .map(|creds| {
                            let client = LoginClient::new(&creds.base_url);
                            let response =
                                client.generate_api_keys(&creds.token, &api_keys.comment);
                            match response {
                                Ok(api_key_response) => {
                                    println!("API Key generated: {:?}", api_key_response);
                                }
                                Err(e) => {
                                    println!("Error: {:?}", e);
                                }
                            }
                        })
                        .unwrap_or_else(|e| {
                            println!("Error: {}. Please login again", e);
                        });
                }
                AuthSubCommand::ListApiKeys => {
                    let creds_result = load_credentials();
                    creds_result
                        .map(|creds| {
                            let client = LoginClient::new(&creds.base_url);
                            let response = client.list_api_keys(&creds.token);
                            match response {
                                Ok(api_keys) => {
                                    println!("API Keys: {:?}", api_keys);
                                }
                                Err(e) => {
                                    println!("Error: {:?}", e);
                                }
                            }
                        })
                        .unwrap_or_else(|e| {
                            println!("Error: {}. Please login again", e);
                        });
                }
            },
            None => {
                println!("No subcommand provided");
            }
        }
    }
}
